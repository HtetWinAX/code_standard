
#!/bin/bash
# Robust YAML-driven Odoo pre-commit hook with auto venv & package repair

set -e

PROJECT_ROOT=$(git rev-parse --show-toplevel)
CONFIG_FILE="$PROJECT_ROOT/.odoo_lint.yaml"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "âŒ Missing config file: $CONFIG_FILE"
    exit 1
fi


# Function to check python version
check_python_version() {
    local py=$1
    "$py" -c "import sys; exit(0) if sys.version_info >= (3,11,9) else exit(1)" >/dev/null 2>&1
}

# Start with the default python (python3 or python)
PYTHON_EXEC="python3"
if ! command -v "$PYTHON_EXEC" >/dev/null 2>&1; then
    PYTHON_EXEC="python"
fi

# Check if current Python is already >= 3.11.9
if check_python_version "$PYTHON_EXEC"; then
    echo "ğŸ Current Python ($PYTHON_EXEC) is compatible (>= $TARGET_PYTHON)"
else
    # Try pyenv if available
    if command -v pyenv >/dev/null 2>&1; then
        echo "âš™ï¸ Pyenv detected. Ensuring Python $TARGET_PYTHON is installed..."
        if ! pyenv versions --bare | grep -q "^$TARGET_PYTHON\$"; then
            echo "ğŸ“¥ Installing Python $TARGET_PYTHON via pyenv..."
            pyenv install "$TARGET_PYTHON"
        fi
        echo "ğŸŒŸ Setting local pyenv Python version to $TARGET_PYTHON..."
        pyenv local "$TARGET_PYTHON"
        PYTHON_EXEC="$(pyenv which python)"
    else
        # Fallback: try system python3.11 if installed
        if command -v python3.11 >/dev/null 2>&1 && check_python_version python3.11; then
            PYTHON_EXEC="python3.11"
        else
            echo "âŒ No compatible Python >= $TARGET_PYTHON found. Please install it."
            exit 1
        fi
    fi
fi

echo "ğŸ Using Python: $PYTHON_EXEC"



# --- Step 0: Ensure virtualenv exists ---
VENV_PATH=".venv"  # default venv, can be overridden by YAML later
PYTHON_PATH="$VENV_PATH/bin/python"

if [ ! -d "$PROJECT_ROOT/$VENV_PATH" ]; then
    echo "âš™ï¸ Creating virtual environment..."
    python3 -m venv "$PROJECT_ROOT/$VENV_PATH"
    echo "âœ… Virtualenv created at $VENV_PATH"
fi

# --- Step 1: Ensure python executable exists ---
if [ ! -x "$PROJECT_ROOT/$PYTHON_PATH" ]; then
    echo "âŒ Python path invalid: $PYTHON_PATH"
    exit 1
fi

# --- Step 2: Upgrade pip & setuptools ---
"$PROJECT_ROOT/$PYTHON_PATH" -m pip install --upgrade pip setuptools wheel >/dev/null 2>&1

# --- Step 3: Ensure PyYAML is installed in venv ---
if ! "$PROJECT_ROOT/$PYTHON_PATH" -c "import yaml" >/dev/null 2>&1; then
    echo "âš™ï¸ Installing PyYAML..."
    "$PROJECT_ROOT/$PYTHON_PATH" -m pip install --quiet pyyaml
fi

# --- Helper: read YAML safely ---
read_yaml() {
    python3 - "$1" <<'EOF'
import sys, json, subprocess

try:
    import yaml
except ModuleNotFoundError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "--quiet", "pyyaml"])
    import yaml

cfg_file = sys.argv[1]
try:
    with open(cfg_file) as f:
        data = yaml.safe_load(f) or {}
    print(json.dumps(data))
except Exception as e:
    print(f"âŒ YAML parsing error in {cfg_file}: {e}", file=sys.stderr)
    sys.exit(1)
EOF
}

CONFIG_JSON=$(read_yaml "$CONFIG_FILE") || exit 1



# --- Extract YAML values ---
get_config_value() {
    echo "$CONFIG_JSON" | python3 -c "
import json, sys
data=json.load(sys.stdin)
print(data.get('$1',''))
"
}

VENV_PATH=$(get_config_value venv_path)
PYTHON_PATH=$(get_config_value python_path)
ODOO_VERSION=$(get_config_value odoo_version)

echo "ğŸ“‚ Project: $PROJECT_ROOT"
echo "ğŸ“¦ Virtualenv path: $VENV_PATH"
echo "ğŸ Python path: $PYTHON_PATH"
echo "ğŸ§© Odoo version: $ODOO_VERSION"

# --- Step 1: Create venv if missing ---
if [ ! -d "$PROJECT_ROOT/$VENV_PATH" ]; then
    echo "âš™ï¸ Creating virtual environment..."
    python3 -m venv "$PROJECT_ROOT/$VENV_PATH"
    echo "âœ… Virtualenv created at $VENV_PATH"
fi

# --- Step 2: Ensure python executable exists ---
if [ ! -x "$PROJECT_ROOT/$PYTHON_PATH" ]; then
    echo "âŒ Python path invalid: $PYTHON_PATH"
    exit 1
fi

# --- Step 3: Upgrade pip and setuptools ---
echo "ğŸ”„ Updating pip and setuptools..."
"$PROJECT_ROOT/$PYTHON_PATH" -m pip install --upgrade pip setuptools wheel >/dev/null 2>&1

# --- Step 4: Install required packages with better error handling ---
REQUIREMENTS=$(echo "$CONFIG_JSON" | python3 -c "
import json, sys
data=json.load(sys.stdin)
print(' '.join(data.get('requirements', [])))
")

if [ -n "$REQUIREMENTS" ]; then
    echo "ğŸ” Checking and installing required packages..."
    for pkg in $REQUIREMENTS; do
        if ! "$PROJECT_ROOT/$PYTHON_PATH" -m pip show "$pkg" >/dev/null 2>&1; then
            echo "ğŸ“¥ Installing missing package: $pkg"
            if "$PROJECT_ROOT/$PYTHON_PATH" -m pip install --quiet "$pkg"; then
                echo "âœ… Installed $pkg"
            else
                echo "âŒ Failed to install $pkg"
                echo "ğŸ’¡ Trying with verbose output..."
                "$PROJECT_ROOT/$PYTHON_PATH" -m pip install "$pkg"
                exit 1
            fi
        else
            echo "âœ… Package $pkg already installed"
        fi
    done
else
    echo "â„¹ï¸ No requirements specified in config"
fi

# --- Step 5: Verify critical packages are installed ---
echo "ğŸ” Verifying critical packages..."
# Map package names to their import names
verify_package() {
    local pkg=$1
    local import_name=$2
    
    if ! "$PROJECT_ROOT/$PYTHON_PATH" -c "import $import_name" 2>/dev/null; then
        echo "âŒ Critical package $pkg not properly installed (cannot import $import_name)"
        echo "ğŸ“¥ Re-installing $pkg..."
        if "$PROJECT_ROOT/$PYTHON_PATH" -m pip install --force-reinstall "$pkg"; then
            echo "âœ… Successfully re-installed $pkg"
            # Verify again after reinstall
            if "$PROJECT_ROOT/$PYTHON_PATH" -c "import $import_name" 2>/dev/null; then
                echo "âœ… Package $pkg now verified"
                return 0
            else
                echo "âŒ Package $pkg still not working after reinstall"
                return 1
            fi
        else
            echo "âŒ Failed to re-install $pkg"
            return 1
        fi
    else
        echo "âœ… Package $pkg verified"
        return 0
    fi
}

# Verify each critical package with correct import names
verify_package "black" "black" || exit 1
verify_package "pylint" "pylint" || exit 1
verify_package "pylint-odoo" "pylint_odoo" || exit 1

echo "âœ… All critical packages verified"

# --- Step 6: Get staged Python files ---
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)
if [ -z "$STAGED_FILES" ]; then
    echo "âœ… No Python files staged."
    exit 0
fi

FAILED=0

# --- Step 7: Black formatting with auto-fix ---
echo "ğŸ”§ Running Black..."
for file in $STAGED_FILES; do
    # First check if the file needs formatting
    if "$PROJECT_ROOT/$PYTHON_PATH" -m black --check "$file" >/dev/null 2>&1; then
        echo "âœ… Black passed: $file"
    else
        echo "âš ï¸  Black formatting needed: $file"
        echo "ğŸ”„ Auto-formatting with Black..."
        if "$PROJECT_ROOT/$PYTHON_PATH" -m black "$file" 2>/dev/null; then
            echo "âœ… Black auto-formatted: $file"
            # Add the formatted file to staging
            git add "$file"
        else
            echo "âŒ Black formatting failed: $file"
            echo "ğŸ’¡ Try running manually: black $file"
            FAILED=1
        fi
    fi
done

# --- Step 8: Build pylint args from YAML ---
echo "ğŸ”§ Building pylint configuration..."

enable=$(echo "$CONFIG_JSON" | python3 -c "
import json, sys
data=json.load(sys.stdin)
enable_list = data.get('enable', [])
if not isinstance(enable_list, list):
    enable_list = [enable_list] if enable_list else []
print(','.join(str(e) for e in enable_list))
")

disable=$(echo "$CONFIG_JSON" | python3 -c "
import json, sys
data=json.load(sys.stdin)
disable_list = data.get('disable', [])
if not isinstance(disable_list, list):
    disable_list = [disable_list] if disable_list else []
print(','.join(str(e) for e in disable_list))
")



# --- Step 9: Run pylint-odoo ---
echo "ğŸ” Running pylint-odoo..."
echo "Addiotional Enable Rule(s): $enable,Addiotional Disable Rule(s): $disable"
for file in $STAGED_FILES; do
    echo "-------------------------------"
    echo "ğŸ“ Checking: $file"
    echo "-------------------------------"
    echo "ğŸ” Command: pylint --load-plugins=pylint_odoo --valid-odoo-versions=$ODOO_VERSION --enable=$enable --disable=$disable $file"
    if "$PROJECT_ROOT/$PYTHON_PATH" -m pylint --load-plugins=pylint_odoo \
        --valid-odoo-versions="$ODOO_VERSION" --enable=$enable --disable=$disable "$file" 2>/dev/null; then
        
        echo "âœ… Pylint passed: $file"
        
        
    else
    	
        echo "âŒ Pylint failed: $file"
        echo "ğŸ“„ Command To Run: pylint --load-plugins=pylint_odoo --valid-odoo-versions=$ODOO_VERSION --enable=$enable --disable=$disable $file"
        
        # Show the actual pylint errors
        #"$PROJECT_ROOT/$PYTHON_PATH" -m pylint --load-plugins=pylint_odoo \
            #--valid-odoo-versions="$ODOO_VERSION" --enable=$enable --disable=$disable "$file" || true
        FAILED=1
        
    fi
done

# --- Step 10: Abort commit if failed ---
if [ $FAILED -ne 0 ]; then
    echo "-------------------------------"
    echo "ğŸš« Commit aborted. Fix formatting/lint issues first."
    echo "ğŸ’¡ Tips:"
    echo "   - Run 'pylint --load-plugins=pylint_odoo your_file.py' to see specific issues"
    exit 1
fi

echo "âœ… All Odoo lint checks and formatting passed successfully!"
exit 0
